<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ImmutableDataLinkFactory.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">speds-link-library</a> &gt; <a href="index.source.html" class="el_package">ca.griis.speds.link.api.sync</a> &gt; <span class="el_source">ImmutableDataLinkFactory.java</span></div><h1>ImmutableDataLinkFactory.java</h1><pre class="source lang-java linenums">/**
 * @file
 *
 * @copyright @@GRIIS_COPYRIGHT@@
 *
 * @licence @@GRIIS_LICENCE@@
 *
 * @version @@GRIIS_VERSION@@
 *
 * @brief @~french Implémentation de la classe ImmutableDataLinkFactory.
 * @brief @~english Implementation of the ImmutableDataLinkFactory class.
 */

package ca.griis.speds.link.api.sync;

import static ca.griis.logger.GriisLoggerFactory.getLogger;

import ca.griis.cryptography.truststore.JavaTrustStore;
import ca.griis.logger.GriisLogger;
import ca.griis.logger.statuscode.Trace;
import ca.griis.speds.communication.protocol.https.HttpsHost;
import ca.griis.speds.link.api.DataLinkFactory;
import ca.griis.speds.link.api.DataLinkHost;
import ca.griis.speds.link.api.dto.InitInParamsDto;
import ca.griis.speds.link.api.exception.ParameterException;
import ca.griis.speds.link.api.exception.ProtocolException;
import ca.griis.speds.link.serializer.SharedObjectMapper;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import io.netty.handler.ssl.SslContext;
import io.netty.handler.ssl.SslContextBuilder;
import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.security.KeyFactory;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.util.Base64;
import java.util.Map;
import java.util.Objects;
import javax.net.ssl.SSLException;
import javax.net.ssl.TrustManagerFactory;

/**
 * @brief @~english «Brief component description (class, interface, ...)»
 * @par Details
 *      «Detailed description of the component (optional)»
 * @par Model
 *      «Model (Abstract, automation, etc.) (optional)»
 * @par Conception
 *      «Conception description (criteria and constraints) (optional)»
 * @par Limits
 *      «Limits description (optional)»
 *
 * @brief @~french Offre une fabriques d'entités nécessaires à la couche liaison.
 * @par Details
 *      S.O.
 * @par Modèle
 *      S.O.
 * @par Conception
 *      S.O.
 * @par Limites
 *      S.O.
 *
 * @par Historique
 *      2025-02-10 [FO] - Première ébauche.
 *
 * @par Tâches
 *      S.O.
 */
<span class="fc" id="L76">public final class ImmutableDataLinkFactory implements DataLinkFactory {</span>
<span class="fc" id="L77">  private static final GriisLogger logger = getLogger(ImmutableDataLinkFactory.class);</span>

<span class="fc" id="L79">  private final ObjectMapper sharedObject = SharedObjectMapper.getInstance().getMapper();</span>

  @Override
  public DataLinkHost init(String parametersJson) {
<span class="fc" id="L83">    logger.trace(Trace.ENTER_METHOD_1, &quot;parametersJson&quot;, parametersJson);</span>

    // Valider et parser les paramètres
<span class="fc" id="L86">    Map&lt;String, Object&gt; parameters = deserializeParameters(parametersJson);</span>

    // Extraire les paramètres
<span class="fc" id="L89">    String protocol = (String) parameters.get(&quot;speds.dl.protocol&quot;);</span>
<span class="fc" id="L90">    String address = (String) parameters.get(&quot;speds.dl.https.server.host&quot;);</span>
<span class="fc" id="L91">    Integer port = (Integer) parameters.get(&quot;speds.dl.https.server.port&quot;);</span>
<span class="fc" id="L92">    String trustManagerMode = (String) parameters</span>
<span class="fc" id="L93">        .getOrDefault(&quot;speds.dl.https.client.cert.trustmanager.mode&quot;, &quot;insecure&quot;);</span>

<span class="fc bfc" id="L95" title="All 6 branches covered.">    if (protocol == null || address == null || port == null) {</span>
<span class="fc" id="L96">      throw new ParameterException(&quot;missing parameters : &quot; + &quot;protocol=&quot; + protocol + &quot; address=&quot;</span>
          + address + &quot; port=&quot; + port);
    }

<span class="fc bfc" id="L100" title="All 2 branches covered.">    if (!protocol.equalsIgnoreCase(&quot;https&quot;)) {</span>
<span class="fc" id="L101">      throw new ProtocolException(&quot;unsupported protocol!&quot;);</span>
    }

    // Configurer les contextes SSL
<span class="fc" id="L105">    SslContext sslContextServer = buildServerSslContext(parameters);</span>
<span class="fc" id="L106">    SslContext sslContextClient = buildClientSslContext(trustManagerMode);</span>

<span class="fc" id="L108">    ImmutableDataLinkHost dataLinkHost = new ImmutableDataLinkHost(sharedObject,</span>
        new HttpsHost(sharedObject, address, port, sslContextClient, sslContextServer));

<span class="fc" id="L111">    logger.trace(Trace.EXIT_METHOD_1, &quot;dataLinkHost&quot;, dataLinkHost);</span>
<span class="fc" id="L112">    return dataLinkHost;</span>
  }


  /**
   * @brief @~english «Description of the function»
   * @param «parameter name» «Parameter description»
   * @exception «exception name» «Exception description»
   * @return «Return description»
   *
   * @brief @~french Deserialiser les paramètres de configuration.
   * @param parametersJson Les paramètres de configuration sous le
   *        format JSON.
   * @return Les paramètres de configuration.
   *
   * @par Tâches
   *      S.O.
   */
  private Map&lt;String, Object&gt; deserializeParameters(String parametersJson) {
<span class="fc" id="L131">    logger.trace(Trace.ENTER_METHOD_1, &quot;parametersJson&quot;, parametersJson);</span>

    InitInParamsDto parameters;

    try {
<span class="fc" id="L136">      parameters = SharedObjectMapper.getInstance().getMapper().readValue(parametersJson,</span>
          InitInParamsDto.class);
<span class="fc" id="L138">    } catch (JsonProcessingException e) {</span>
<span class="fc" id="L139">      throw new ParameterException(&quot;Invalid parameters format&quot;, e);</span>
<span class="fc" id="L140">    }</span>

<span class="fc" id="L142">    Map&lt;String, Object&gt; options = parameters.getOptions();</span>

<span class="fc" id="L144">    logger.trace(Trace.EXIT_METHOD_1, &quot;options&quot;, options);</span>

<span class="fc" id="L146">    return options;</span>
  }

  /**
   * @brief @~english «Description of the function»
   * @param «parameter name» «Parameter description»
   * @exception «exception name» «Exception description»
   * @return «Return description»
   *
   * @brief @~french Construire le contexte ssl du serveur.
   * @param parameters Les paramètres de configuration
   * @return Le contexte ssl du serveur.
   *
   * @par Tâches
   *      S.O.
   */
  private SslContext buildServerSslContext(Map&lt;String, Object&gt; parameters) {
<span class="fc" id="L163">    logger.trace(Trace.ENTER_METHOD_1, &quot;parameters&quot;, parameters);</span>

<span class="fc" id="L165">    SslContext sslContext = null;</span>

    try {
<span class="fc" id="L168">      X509Certificate certificate = base64ToCertificate((String) Objects.requireNonNull(</span>
<span class="fc" id="L169">          parameters.get(&quot;speds.dl.https.server.cert&quot;), &quot;Server certificate is required&quot;));</span>
<span class="fc" id="L170">      PrivateKey privateKey = base64ToPrivateKey((String) Objects.requireNonNull(</span>
<span class="fc" id="L171">          parameters.get(&quot;speds.dl.https.server.private.key&quot;), &quot;Server private key is required&quot;));</span>

<span class="fc" id="L173">      sslContext = SslContextBuilder.forServer(privateKey, certificate)</span>
<span class="fc" id="L174">          .trustManager(InsecureTrustManagerFactory.INSTANCE).build();</span>
<span class="nc" id="L175">    } catch (SSLException e) {</span>
<span class="nc" id="L176">      throw new ProtocolException(&quot;Error initiating SSL context for server&quot;, e);</span>
<span class="fc" id="L177">    }</span>

<span class="fc" id="L179">    logger.trace(Trace.EXIT_METHOD_1, &quot;sslContext&quot;, sslContext);</span>
<span class="fc" id="L180">    return sslContext;</span>
  }

  /**
   * @brief @~english «Description of the function»
   * @param «parameter name» «Parameter description»
   * @exception «exception name» «Exception description»
   * @return «Return description»
   *
   * @brief @~french Construire le contexte ssl du client.
   * @param trustManagerMode Le mode de gestion des certificats
   * @return Le contexte ssl du client.
   *
   * @par Tâches
   *      S.O.
   */
  private SslContext buildClientSslContext(String trustManagerMode) {
<span class="fc" id="L197">    logger.trace(Trace.ENTER_METHOD_1, &quot;trustManagerMode&quot;, trustManagerMode);</span>

<span class="fc" id="L199">    SslContext sslContext = null;</span>
    try {
      TrustManagerFactory trustManagerFactory =
<span class="fc bfc" id="L202" title="All 2 branches covered.">          &quot;default&quot;.equals(trustManagerMode) ? JavaTrustStore.getDefaultTrustFactoryManager()</span>
<span class="fc" id="L203">              : InsecureTrustManagerFactory.INSTANCE;</span>

<span class="fc" id="L205">      sslContext = SslContextBuilder.forClient().trustManager(trustManagerFactory).build();</span>
<span class="nc" id="L206">    } catch (SSLException e) {</span>
<span class="nc" id="L207">      throw new ProtocolException(&quot;Error initiating SSL context for client&quot;, e);</span>
<span class="fc" id="L208">    }</span>

<span class="fc" id="L210">    logger.trace(Trace.EXIT_METHOD_1, &quot;sslContext&quot;, sslContext);</span>
<span class="fc" id="L211">    return sslContext;</span>
  }

  /**
   * @brief @~english «Description of the function»
   * @param «parameter name» «Parameter description»
   * @exception «exception name» «Exception description»
   * @return «Return description»
   *
   * @brief @~french Parser une chaine base64 en certificat.
   * @param base64Certificate La chaine encodée en base64
   * @return Le certificat.
   *
   * @par Tâches
   *      S.O.
   */
  private X509Certificate base64ToCertificate(String base64Certificate) {
<span class="fc" id="L228">    logger.trace(Trace.ENTER_METHOD_1, &quot;base64Certificate&quot;, base64Certificate);</span>

<span class="fc" id="L230">    X509Certificate x509Certificate = null;</span>

    try {
<span class="fc" id="L233">      byte[] certificateBytes = Base64.getDecoder().decode(base64Certificate);</span>
<span class="fc" id="L234">      CertificateFactory certificateFactory = CertificateFactory.getInstance(&quot;X.509&quot;);</span>

<span class="fc" id="L236">      try (ByteArrayInputStream inputStream = new ByteArrayInputStream(certificateBytes)) {</span>
<span class="fc" id="L237">        x509Certificate = (X509Certificate) certificateFactory.generateCertificate(inputStream);</span>
      }
<span class="fc" id="L239">    } catch (IOException | CertificateException | IllegalArgumentException e) {</span>
<span class="fc" id="L240">      throw new ParameterException(&quot;Invalid Base64 encoded Certificate&quot;);</span>
<span class="fc" id="L241">    }</span>

<span class="fc" id="L243">    logger.trace(Trace.EXIT_METHOD_1, &quot;x509Certificate&quot;, x509Certificate);</span>
<span class="fc" id="L244">    return x509Certificate;</span>
  }

  /**
   * @brief @~english «Description of the function»
   * @param «parameter name» «Parameter description»
   * @exception «exception name» «Exception description»
   * @return «Return description»
   *
   * @brief @~french Parser une chaine base64 en clé privée.
   * @param base64PrivateKey La chaine encodée en base64
   * @return La clé privée.
   *
   * @par Tâches
   *      S.O.
   */
  private PrivateKey base64ToPrivateKey(String base64PrivateKey) {
<span class="fc" id="L261">    logger.trace(Trace.ENTER_METHOD_1, &quot;base64PrivateKey&quot;, base64PrivateKey);</span>

<span class="fc" id="L263">    PrivateKey privateKey = null;</span>
    try {
<span class="fc" id="L265">      byte[] privateKeyBytes = Base64.getDecoder().decode(base64PrivateKey);</span>
<span class="fc" id="L266">      PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(privateKeyBytes);</span>
<span class="fc" id="L267">      KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;);</span>
<span class="fc" id="L268">      privateKey = keyFactory.generatePrivate(keySpec);</span>
<span class="fc" id="L269">    } catch (NoSuchAlgorithmException | InvalidKeySpecException | IllegalArgumentException e) {</span>
<span class="fc" id="L270">      throw new ParameterException(&quot;Invalid Base64 encoded Key&quot;);</span>
<span class="fc" id="L271">    }</span>

<span class="fc" id="L273">    logger.trace(Trace.EXIT_METHOD_1, &quot;privateKey&quot;, privateKey);</span>
<span class="fc" id="L274">    return privateKey;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>