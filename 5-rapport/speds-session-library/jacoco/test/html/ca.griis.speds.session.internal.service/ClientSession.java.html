<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ClientSession.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">speds-session-library</a> &gt; <a href="index.source.html" class="el_package">ca.griis.speds.session.internal.service</a> &gt; <span class="el_source">ClientSession.java</span></div><h1>ClientSession.java</h1><pre class="source lang-java linenums">/**
 * @file
 *
 * @copyright @@GRIIS_COPYRIGHT@@
 *
 * @licence @@GRIIS_LICENCE@@
 *
 * @version @@GRIIS_VERSION@@
 *
 * @brief @~french Implémentation de la classe ClientSession.
 * @brief @~english Implementation of the ClientSession class.
 */

package ca.griis.speds.session.internal.service;

import ca.griis.cryptography.asymmetric.keypair.CertificatePrivateKeysEntry;
import ca.griis.cryptography.symmetric.encryption.AesGcmDecryptor;
import ca.griis.cryptography.symmetric.encryption.AesGcmEncryptor;
import ca.griis.js2p.gen.speds.session.api.dto.HeaderDto;
import ca.griis.js2p.gen.speds.session.api.dto.InterfaceDataUnit23Dto;
import ca.griis.js2p.gen.speds.session.api.dto.SPEDSDto;
import ca.griis.js2p.gen.speds.session.api.dto.cle.KeyTransferDto;
import ca.griis.js2p.gen.speds.session.api.dto.cle.SesCleEnvDto;
import ca.griis.js2p.gen.speds.session.api.dto.cle.SesCleRecDto;
import ca.griis.js2p.gen.speds.session.api.dto.fin.SesFinEnvDto;
import ca.griis.js2p.gen.speds.session.api.dto.fin.SesFinRecDto;
import ca.griis.js2p.gen.speds.session.api.dto.msg.SesMsgEnvDto;
import ca.griis.js2p.gen.speds.session.api.dto.msg.SesMsgRecDto;
import ca.griis.js2p.gen.speds.session.api.dto.sak.SesSakEnvDto;
import ca.griis.js2p.gen.speds.session.api.dto.sak.SesSakRecDto;
import ca.griis.logger.GriisLogger;
import ca.griis.logger.GriisLoggerFactory;
import ca.griis.logger.statuscode.Debug;
import ca.griis.logger.statuscode.Trace;
import ca.griis.speds.session.api.PgaService;
import ca.griis.speds.session.api.exception.DeserializationException;
import ca.griis.speds.session.api.exception.InvalidTokenException;
import ca.griis.speds.session.api.exception.SessionTerminaisonFailedException;
import ca.griis.speds.session.internal.contract.MsgType;
import ca.griis.speds.session.internal.contract.Pidu;
import ca.griis.speds.session.internal.contract.PiduContext;
import ca.griis.speds.session.internal.contract.SesPubEnvDto;
import ca.griis.speds.session.internal.contract.Sidu;
import ca.griis.speds.session.internal.contract.SiduContext;
import ca.griis.speds.session.internal.contract.Spdu;
import ca.griis.speds.session.internal.contract.SpduHeader;
import ca.griis.speds.session.internal.domain.ExpandedSidu;
import ca.griis.speds.session.internal.domain.HostStartupContext;
import ca.griis.speds.session.internal.domain.PiduAndSession;
import ca.griis.speds.session.internal.domain.SessionId;
import ca.griis.speds.session.internal.handler.HandlerRegistry;
import ca.griis.speds.session.internal.handler.initiator.InitiatorHandlerRegistry;
import ca.griis.speds.session.internal.model.PendingConfirmation;
import ca.griis.speds.session.internal.model.SessionInformation;
import ca.griis.speds.session.internal.processing.Poller;
import ca.griis.speds.session.internal.service.crypto.KeyAgreement;
import ca.griis.speds.session.internal.service.seal.SealCreator;
import ca.griis.speds.session.internal.util.KeyAlgorithm;
import ca.griis.speds.session.internal.util.KeyMapping;
import ca.griis.speds.transport.api.TransportHost;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.nio.charset.StandardCharsets;
import java.security.KeyPair;
import java.security.PublicKey;
import java.time.Duration;
import java.util.Base64;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.UUID;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.LinkedBlockingDeque;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;

/**
 * @brief @~english «Brief component description (class, interface, ...)»
 * @par Details
 *      «Detailed description of the component (optional)»
 * @par Model
 *      «Model (Abstract, automation, etc.) (optional)»
 * @par Conception
 *      «Conception description (criteria and constraints) (optional)»
 * @par Limits
 *      «Limits description (optional)»
 *
 * @brief @~french Implémente la logique métier d’un client gérant la couche session
 * @par Details
 *      S.O.
 * @par Modèle
 *      S.O.
 * @par Conception
 *      S.O.
 * @par Limites
 *      S.O.
 *
 * @par Historique
 *      2025-03-17 [SSC] - Implémentation initiale&lt;br&gt;
 *      2025-05-14 [CB] - Refact - itération 2&lt;br&gt;
 *      2025-06-29 [MD] - Refact - itération 4&lt;br&gt;
 *
 * @par Tâches
 *      S.O.
 */
public final class ClientSession {
<span class="fc" id="L111">  private static final GriisLogger logger = GriisLoggerFactory.getLogger(ClientSession.class);</span>

<span class="fc" id="L113">  private static final ExpandedSidu poisonPill = new ExpandedSidu(null, null, null);</span>

  private final PgaService pgaService;
  private final ObjectMapper sharedMapper;
  private final SealCreator sealCreator;
  private final SPEDSDto speds;
  private final TransportHost transportHost;
  private final Poller poller;

  private final ConcurrentLinkedQueue&lt;PendingConfirmation&gt; pendingResponse;
  private final BlockingQueue&lt;ExpandedSidu&gt; messageWeHandle;
  private final Map&lt;SessionId, SessionInformation&gt; sessionInformations;
  private final CertificatePrivateKeysEntry hostCertificate;
  private final Duration clientTimeout;
  private final LinkedBlockingQueue&lt;InterfaceDataUnit23Dto&gt; pidus;

  public ClientSession(HostStartupContext hostStartupContext, Poller poller,
<span class="fc" id="L130">      LinkedBlockingQueue&lt;InterfaceDataUnit23Dto&gt; pidus) {</span>
<span class="fc" id="L131">    logger.trace(Trace.ENTER_METHOD_2, &quot;hostStartupContext&quot;, hostStartupContext, &quot;poller&quot;, poller);</span>
<span class="fc" id="L132">    this.messageWeHandle = new LinkedBlockingDeque&lt;&gt;();</span>
<span class="fc" id="L133">    this.pendingResponse = new ConcurrentLinkedQueue&lt;&gt;();</span>
<span class="fc" id="L134">    this.pidus = pidus;</span>
<span class="fc" id="L135">    this.pgaService = hostStartupContext.pgaService();</span>
<span class="fc" id="L136">    this.sessionInformations = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L137">    this.hostCertificate = hostStartupContext.hostKeys();</span>
<span class="fc" id="L138">    this.sharedMapper = hostStartupContext.sharedMapper();</span>
<span class="fc" id="L139">    this.speds = hostStartupContext.spedsDto();</span>
<span class="fc" id="L140">    this.transportHost = hostStartupContext.transportHost();</span>
<span class="fc" id="L141">    this.clientTimeout = hostStartupContext.responseTimeout();</span>
<span class="fc" id="L142">    this.poller = poller;</span>
<span class="fc" id="L143">    HandlerRegistry handlerRegistry = new InitiatorHandlerRegistry(sharedMapper, pgaService,</span>
        messageWeHandle, sessionInformations);
<span class="fc" id="L145">    this.poller.registerHandlers(handlerRegistry);</span>
<span class="fc" id="L146">    this.sealCreator = new SealCreator();</span>
<span class="fc" id="L147">  }</span>

  public void close() {
<span class="nc" id="L150">    closePreservingSessionStates();</span>
<span class="nc" id="L151">    sessionInformations.clear();</span>
<span class="nc" id="L152">  }</span>

  public void closePreservingSessionStates() {
<span class="fc" id="L155">    saveSessionState();</span>

<span class="fc" id="L157">    poller.stop();</span>
<span class="fc" id="L158">    transportHost.close();</span>
<span class="fc" id="L159">    pendingResponse.clear();</span>
<span class="fc" id="L160">    messageWeHandle.clear();</span>

    try {
<span class="fc" id="L163">      messageWeHandle.put(poisonPill);</span>
<span class="nc" id="L164">    } catch (InterruptedException e) {</span>
<span class="nc" id="L165">      Thread.currentThread().interrupt();</span>
<span class="fc" id="L166">    }</span>
<span class="fc" id="L167">  }</span>

  public void clearSessionStates() {
<span class="fc" id="L170">    sessionInformations.clear();</span>
<span class="fc" id="L171">  }</span>

  public void sendMessageWithManagedSession(Pidu pidu) throws JsonProcessingException {
<span class="fc" id="L174">    logger.trace(Trace.ENTER_METHOD_1, &quot;pidu&quot;, pidu);</span>
    // init a session
<span class="fc" id="L176">    SessionId sessionId = new SessionId(UUID.randomUUID());</span>

<span class="fc" id="L178">    PublicKey publicKey = hostCertificate.getCertficate().getPublicKey();</span>
<span class="fc" id="L179">    final String initiatorPubKey = Base64.getEncoder().encodeToString(publicKey.getEncoded());</span>
<span class="fc" id="L180">    final String initiatorIri = pgaService.getIri(pidu.getContext().getPga(),</span>
<span class="fc" id="L181">        pidu.getContext().getSourceCode());</span>
<span class="fc" id="L182">    final String peerIri = pgaService.getIri(pidu.getContext().getPga(),</span>
<span class="fc" id="L183">        pidu.getContext().getDestinationCode());</span>

<span class="fc" id="L185">    byte[] keyBytes = Base64.getDecoder().decode(pidu.getContext().getSdek());</span>
<span class="fc" id="L186">    SecretKey secretKey = new SecretKeySpec(keyBytes, 0, keyBytes.length, &quot;AES&quot;);</span>

<span class="fc" id="L188">    SessionInformation sessionInfo = SessionInformation.builder()</span>
<span class="fc" id="L189">        .sessionId(sessionId)</span>
<span class="fc" id="L190">        .initiatorId(pidu.getContext().getSourceCode())</span>
<span class="fc" id="L191">        .initiatorIri(initiatorIri)</span>
<span class="fc" id="L192">        .initiatorPubKey(initiatorPubKey)</span>
<span class="fc" id="L193">        .sdek(secretKey)</span>
<span class="fc" id="L194">        .peerId(pidu.getContext().getDestinationCode())</span>
<span class="fc" id="L195">        .peerIri(peerIri)</span>
<span class="fc" id="L196">        .piduMessage(pidu.getMessage())</span>
<span class="fc" id="L197">        .pgaId(pidu.getContext().getPga())</span>
<span class="fc" id="L198">        .numberOfMessage(0)</span>
<span class="fc" id="L199">        .build();</span>
<span class="fc" id="L200">    this.sessionInformations.put(sessionId, sessionInfo);</span>

    // call initSession
<span class="fc" id="L203">    sendPubEnv(pidu, sessionId);</span>

<span class="fc" id="L205">    Optional&lt;Pidu&gt; outPidu = Optional.empty();</span>

<span class="fc bfc" id="L207" title="All 2 branches covered.">    while (!pendingResponse.isEmpty()) {</span>
      try {
<span class="fc" id="L209">        ExpandedSidu expandedSidu =</span>
<span class="fc" id="L210">            messageWeHandle.poll(clientTimeout.getSeconds(), TimeUnit.SECONDS);</span>
<span class="fc" id="L211">        Objects.requireNonNull(expandedSidu);</span>

<span class="pc bpc" id="L213" title="1 of 2 branches missed.">        if (!expandedSidu.equals(poisonPill)) {</span>
<span class="fc" id="L214">          PiduAndSession msgResponse = handleSession(expandedSidu);</span>

<span class="fc bfc" id="L216" title="All 4 branches covered.">          if (outPidu.isEmpty() &amp;&amp; msgResponse != null) {</span>
<span class="fc" id="L217">            outPidu = Optional.ofNullable(msgResponse.pidu());</span>
<span class="fc" id="L218">            pidus.add(outPidu.get());</span>
          }
<span class="fc" id="L220">        } else {</span>
<span class="nc" id="L221">          pendingResponse.clear();</span>
<span class="nc" id="L222">          logger.debug(Debug.VARIABLE_LOGGING_1, &quot;poisonPill&quot;, poisonPill);</span>
        }
<span class="nc" id="L224">      } catch (InterruptedException e) {</span>
<span class="nc" id="L225">        Thread.currentThread().interrupt();</span>
<span class="pc" id="L226">      }</span>
    }

<span class="fc" id="L229">    logger.trace(Trace.EXIT_METHOD_0);</span>
<span class="fc" id="L230">  }</span>

  private PiduAndSession handleSession(ExpandedSidu expandedSidu) throws JsonProcessingException {
<span class="fc" id="L233">    PiduAndSession msgResponse = null;</span>
<span class="pc bpc" id="L234" title="1 of 6 branches missed.">    switch (expandedSidu.msgType()) {</span>
<span class="fc" id="L235">      case SES_PUB_REC -&gt; sendSkak(expandedSidu);</span>
<span class="fc" id="L236">      case SES_SAK_REC -&gt; sendSdek(expandedSidu);</span>
<span class="fc" id="L237">      case SES_CLE_REC -&gt; sendMsg(expandedSidu);</span>
<span class="fc" id="L238">      case SES_MSG_REC -&gt; msgResponse = retrieveAnswer(expandedSidu);</span>
<span class="fc" id="L239">      case SES_FIN_REC -&gt; closeSession(expandedSidu);</span>
<span class="nc" id="L240">      default -&gt; throw new IllegalArgumentException(&quot;Unexpected message type: &quot;</span>
<span class="nc" id="L241">          + expandedSidu.msgType());</span>
    }

<span class="fc bfc" id="L244" title="All 2 branches covered.">    if (msgResponse != null) {</span>
      // Supprimer du Tableau des réponses en attente, l’entrée de SES.MSG.ENV d’identifiant
      // id.
<span class="fc" id="L247">      PendingConfirmation match = this.pendingResponse.stream()</span>
<span class="fc" id="L248">          .filter(x -&gt; x.uniqueId().equals(expandedSidu.spdu().getHeader().getId()))</span>
<span class="fc" id="L249">          .findFirst()</span>
<span class="pc" id="L250">          .orElseThrow(() -&gt; new IllegalStateException(&quot;Element not found&quot;));</span>
<span class="fc" id="L251">      this.pendingResponse.remove(match);</span>

      // Session is done we close
<span class="fc" id="L254">      sendClose(msgResponse);</span>
    }

<span class="fc" id="L257">    return msgResponse;</span>
  }

  public void sendPubEnv(Pidu pidu, SessionId sessionId) {
<span class="fc" id="L261">    logger.trace(Trace.ENTER_METHOD_2, &quot;pidu&quot;, pidu, &quot;sessionId&quot;, sessionId);</span>

<span class="fc" id="L263">    SessionInformation currentSession = this.sessionInformations.get(sessionId);</span>

    // Créer une SDU SES.PUB.ENV pour transmettre la clé publique avec le numéro de la session

    // Créer une SDU de type SES_PUB_ENV
<span class="fc" id="L268">    String pubKey = currentSession.initiatorPubKey;</span>
<span class="fc" id="L269">    SesPubEnvDto sesPubEnvDto = new SesPubEnvDto(pubKey, currentSession.sessionId.id());</span>

    // Construire la SPDU
<span class="fc" id="L272">    SpduHeader spduHeader = new SpduHeader(HeaderDto.Msgtype.SES_PUB_ENV, UUID.randomUUID(),</span>
<span class="fc" id="L273">        false,</span>
        speds);
<span class="fc" id="L275">    Spdu spdu = null;</span>
    try {
<span class="fc" id="L277">      spdu = new Spdu(spduHeader, &quot;0&quot;, sharedMapper.writeValueAsString(sesPubEnvDto));</span>
<span class="nc" id="L278">    } catch (JsonProcessingException e) {</span>
<span class="nc" id="L279">      throw new RuntimeException(e);</span>
<span class="fc" id="L280">    }</span>

    // Construire le SIDU
<span class="fc" id="L283">    String sourceIri = currentSession.initiatorIri;</span>
<span class="fc" id="L284">    String destinationIri = currentSession.peerIri;</span>
<span class="fc" id="L285">    SiduContext siduContext = new SiduContext(</span>
<span class="fc" id="L286">        pidu.getContext().getSourceCode(),</span>
<span class="fc" id="L287">        pidu.getContext().getDestinationCode(),</span>
        sourceIri,
<span class="fc" id="L289">        spduHeader.getId(),</span>
        destinationIri,
<span class="fc" id="L291">        false);</span>

    String serialSidu;
    try {
<span class="fc" id="L295">      Sidu sidu = new Sidu(siduContext, sharedMapper.writeValueAsString(spdu));</span>
<span class="fc" id="L296">      serialSidu = sharedMapper.writeValueAsString(sidu);</span>
<span class="nc" id="L297">    } catch (JsonProcessingException e) {</span>
<span class="nc" id="L298">      throw new RuntimeException(e);</span>
<span class="fc" id="L299">    }</span>

    // Transmettre la IDU à la couche inférieure et attendre qu’une réponse de type [SES.PUB.REC] et
    // d’identifiant le id
<span class="fc" id="L303">    pendingResponse</span>
<span class="fc" id="L304">        .add(new PendingConfirmation(spduHeader.getId(), sessionId, MsgType.SES_PUB_ENV));</span>

<span class="fc" id="L306">    logger.trace(Trace.ALGORITHM_1, &quot;serialSidu&quot;, serialSidu);</span>

<span class="fc" id="L308">    transportHost.dataRequest(serialSidu);</span>
<span class="fc" id="L309">    transportHost.dataConfirm();</span>

<span class="fc" id="L311">    logger.trace(Trace.EXIT_METHOD_0);</span>
<span class="fc" id="L312">  }</span>

  public void sendSkak(ExpandedSidu expandedSidu) throws JsonProcessingException {
    // Supprimer du Tableau des réponses en attente, l’entrée de SES.PUB.ENV d’identifiant id.
<span class="fc" id="L316">    PendingConfirmation match = this.pendingResponse.stream()</span>
<span class="fc" id="L317">        .filter(x -&gt; x.uniqueId().equals(expandedSidu.spdu().getHeader().getId()))</span>
<span class="fc" id="L318">        .findFirst()</span>
<span class="pc" id="L319">        .orElseThrow(() -&gt; new IllegalStateException(&quot;Element not found&quot;));</span>
<span class="fc" id="L320">    this.pendingResponse.remove(match);</span>
<span class="fc" id="L321">    SessionInformation session = this.sessionInformations.get(match.sessionId());</span>

    // Créer une SDU de type SES.SAK.ENV
    // Déterminer le choix de la clef
<span class="fc" id="L325">    KeyAgreement keyAgreement = new KeyAgreement();</span>
<span class="fc" id="L326">    KeyPair choiceKeyPair = keyAgreement.generateChoicePointKey();</span>
<span class="fc" id="L327">    String choice = Base64.getEncoder().encodeToString(choiceKeyPair.getPublic().getEncoded());</span>
<span class="fc" id="L328">    String serialId = session.sessionId.id().toString();</span>
<span class="fc" id="L329">    SesSakEnvDto sdu = new SesSakEnvDto(choice, serialId);</span>
<span class="fc" id="L330">    String serialSdu = sharedMapper.writeValueAsString(sdu);</span>
<span class="fc" id="L331">    session.firstChoice = choiceKeyPair;</span>

    // Construire la SPDU
<span class="fc" id="L334">    SpduHeader spduHeader = new SpduHeader(HeaderDto.Msgtype.SES_SAK_ENV, UUID.randomUUID(),</span>
<span class="fc" id="L335">        false, speds);</span>
<span class="fc" id="L336">    String stamp = sealCreator.createSeal(serialSdu, hostCertificate.getPrivateKey(), sharedMapper);</span>
<span class="fc" id="L337">    Spdu spdu = new Spdu(spduHeader, stamp, serialSdu);</span>

    // Construire le SIDU
<span class="fc" id="L340">    SiduContext siduContext = new SiduContext(</span>
        session.initiatorId,
        session.peerId,
        session.initiatorIri,
<span class="fc" id="L344">        spduHeader.getId(),</span>
        session.peerIri,
<span class="fc" id="L346">        false);</span>
    String serialSidu;
    try {
<span class="fc" id="L349">      Sidu sidu = new Sidu(siduContext, sharedMapper.writeValueAsString(spdu));</span>
<span class="fc" id="L350">      serialSidu = sharedMapper.writeValueAsString(sidu);</span>
<span class="nc" id="L351">    } catch (JsonProcessingException e) {</span>
<span class="nc" id="L352">      throw new RuntimeException(e);</span>
<span class="fc" id="L353">    }</span>

    // Transmettre la IDU à la couche inférieure &amp;&amp; inscrire qu'on attend une réponse pour
    // SES_SAK_ENV
<span class="fc" id="L357">    pendingResponse</span>
<span class="fc" id="L358">        .add(new PendingConfirmation(spduHeader.getId(), session.sessionId, MsgType.SES_SAK_ENV));</span>

<span class="fc" id="L360">    transportHost.dataRequest(serialSidu);</span>
<span class="fc" id="L361">    transportHost.dataConfirm();</span>

<span class="fc" id="L363">    logger.trace(Trace.EXIT_METHOD_0);</span>
<span class="fc" id="L364">  }</span>

  public void sendSdek(ExpandedSidu expandedSidu) throws JsonProcessingException {
    // Supprimer du Tableau des réponses en attente, l’entrée de SES.SAK.ENV d’identifiant id.
<span class="fc" id="L368">    PendingConfirmation match = this.pendingResponse.stream()</span>
<span class="fc" id="L369">        .filter(x -&gt; x.uniqueId().equals(expandedSidu.spdu().getHeader().getId()))</span>
<span class="fc" id="L370">        .findFirst()</span>
<span class="pc" id="L371">        .orElseThrow(() -&gt; new IllegalStateException(&quot;Element not found&quot;));</span>
<span class="fc" id="L372">    this.pendingResponse.remove(match);</span>
<span class="fc" id="L373">    SessionInformation session = this.sessionInformations.get(match.sessionId());</span>

    // Déterminer / mémoriser SKAK
<span class="fc" id="L376">    KeyAgreement keyAgreement = new KeyAgreement();</span>
<span class="fc" id="L377">    SesSakRecDto sesSakRecDto =</span>
<span class="fc" id="L378">        sharedMapper.readValue((String) expandedSidu.spdu().getContent(), SesSakRecDto.class);</span>
<span class="fc" id="L379">    PublicKey peerChoice =</span>
<span class="fc" id="L380">        KeyMapping.getPublicKeyFromString(sesSakRecDto.getValue(), KeyAlgorithm.X25519);</span>
<span class="fc" id="L381">    byte[] skakByte = keyAgreement.completeKeyAgreementNegotiation(session.firstChoice,</span>
        peerChoice);
<span class="fc" id="L383">    SecretKey skak = KeyMapping.getAesSecretKeyFromByte(skakByte);</span>
<span class="fc" id="L384">    session.skak = skak;</span>

<span class="fc" id="L386">    UUID sessionToken = UUID.randomUUID();</span>
<span class="fc" id="L387">    SessionInformation updatedInfo = SessionInformation.builder()</span>
<span class="fc" id="L388">        .of(session)</span>
<span class="fc" id="L389">        .token(sessionToken)</span>
<span class="fc" id="L390">        .build();</span>
<span class="fc" id="L391">    sessionInformations.put(match.sessionId(), updatedInfo);</span>

    // Procéder à l’envoi de la clé de chiffrement SDEK
    // Créer SDU
<span class="fc" id="L395">    byte[] keyBytes = session.sdek.getEncoded();</span>
<span class="fc" id="L396">    String serialKey = Base64.getEncoder().encodeToString(keyBytes);</span>
<span class="fc" id="L397">    KeyTransferDto keyTransferDto = new KeyTransferDto(serialKey, session.pgaId, sessionToken);</span>
<span class="fc" id="L398">    AesGcmEncryptor symmetricEncrypt = new AesGcmEncryptor(skak);</span>
<span class="fc" id="L399">    byte[] cryptedKeyTrans =</span>
<span class="fc" id="L400">        symmetricEncrypt.encrypt(sharedMapper.writeValueAsBytes(keyTransferDto));</span>
<span class="fc" id="L401">    String serialKeyTrans = Base64.getEncoder().encodeToString(cryptedKeyTrans);</span>
<span class="fc" id="L402">    SesCleEnvDto sdu = new SesCleEnvDto(serialKeyTrans, session.sessionId.id());</span>

    // Construire la SPDU
<span class="fc" id="L405">    SpduHeader spduHeader = new SpduHeader(HeaderDto.Msgtype.SES_CLE_ENV,</span>
<span class="fc" id="L406">        UUID.randomUUID(), false, speds);</span>

<span class="fc" id="L408">    String stamp = sealCreator.createSymmetricalSeal(sdu, skak, sharedMapper);</span>
<span class="fc" id="L409">    Spdu spdu = new Spdu(spduHeader, stamp, sharedMapper.writeValueAsString(sdu));</span>

    // Construire la SIDU
<span class="fc" id="L412">    SiduContext siduContext = new SiduContext(</span>
        session.initiatorId,
        session.peerId,
        session.initiatorIri,
<span class="fc" id="L416">        spdu.getHeader().getId(),</span>
        session.peerIri,
<span class="fc" id="L418">        false);</span>
    String serialSidu;
    try {
<span class="fc" id="L421">      Sidu sidu = new Sidu(siduContext, sharedMapper.writeValueAsString(spdu));</span>
<span class="fc" id="L422">      serialSidu = sharedMapper.writeValueAsString(sidu);</span>
<span class="nc" id="L423">    } catch (JsonProcessingException e) {</span>
<span class="nc" id="L424">      throw new RuntimeException(e);</span>
<span class="fc" id="L425">    }</span>

    // Transmettre la IDU à la couche inférieur &amp;&amp; inscrire qu'on attend une réponse pour
    // SES_CLE_ENV
<span class="fc" id="L429">    pendingResponse</span>
<span class="fc" id="L430">        .add(new PendingConfirmation(spduHeader.getId(), session.sessionId, MsgType.SES_CLE_ENV));</span>
<span class="fc" id="L431">    logger.trace(Trace.ALGORITHM_1, serialSidu, serialSidu);</span>

<span class="fc" id="L433">    transportHost.dataRequest(serialSidu);</span>
<span class="fc" id="L434">    transportHost.dataConfirm();</span>

<span class="fc" id="L436">    logger.trace(Trace.EXIT_METHOD_0);</span>
<span class="fc" id="L437">  }</span>

  public void sendMsg(ExpandedSidu expandedSidu) throws JsonProcessingException {
<span class="fc" id="L440">    logger.trace(Trace.ENTER_METHOD_1, &quot;expandedSidu&quot;, expandedSidu);</span>

    // Supprimer du Tableau des réponses en attente, l’entrée de SES.CLE.ENV d’identifiant id.
<span class="fc" id="L443">    PendingConfirmation match = this.pendingResponse.stream()</span>
<span class="fc" id="L444">        .filter(x -&gt; x.uniqueId().equals(expandedSidu.spdu().getHeader().getId()))</span>
<span class="fc" id="L445">        .findFirst()</span>
<span class="pc" id="L446">        .orElseThrow(() -&gt; new IllegalStateException(&quot;Element not found&quot;));</span>
<span class="fc" id="L447">    this.pendingResponse.remove(match);</span>
<span class="fc" id="L448">    SessionInformation session = this.sessionInformations.get(match.sessionId());</span>
<span class="fc" id="L449">    SesCleRecDto sesCleRecDto =</span>
<span class="fc" id="L450">        sharedMapper.readValue((String) expandedSidu.spdu().getContent(), SesCleRecDto.class);</span>

    try {
<span class="fc" id="L453">      byte[] encryptedToken = Base64.getDecoder().decode(sesCleRecDto.getContent());</span>
<span class="fc" id="L454">      AesGcmDecryptor aesGcmDecryptor = new AesGcmDecryptor(session.sdek);</span>
<span class="fc" id="L455">      byte[] decryptedToken = aesGcmDecryptor.decrypt(encryptedToken);</span>
<span class="fc" id="L456">      UUID token = UUID.fromString(new String(decryptedToken, StandardCharsets.UTF_8));</span>
<span class="pc bpc" id="L457" title="1 of 2 branches missed.">      if (token.compareTo(session.token) != 0) {</span>
<span class="nc" id="L458">        throw new InvalidTokenException(&quot;Token is invalid&quot;);</span>
      }
<span class="fc" id="L460">    } catch (Exception e) {</span>
<span class="fc" id="L461">      throw new InvalidTokenException(&quot;Impossible to retrieve the token&quot;);</span>
<span class="fc" id="L462">    }</span>

    // Procéder à l’envoi du message à transmettre
    // Créer une SDU SES.MSG.ENV
<span class="fc" id="L466">    SesMsgEnvDto sdu = new SesMsgEnvDto(session.piduMessage, session.sessionId.id());</span>

    // Construire la SPDU
<span class="fc" id="L469">    SpduHeader spduHeader = new SpduHeader(HeaderDto.Msgtype.SES_MSG_ENV,</span>
<span class="fc" id="L470">        UUID.randomUUID(),</span>
<span class="fc" id="L471">        false,</span>
        speds);
<span class="fc" id="L473">    String stamp = sealCreator.createSymmetricalSeal(sdu, session.skak, sharedMapper);</span>
<span class="fc" id="L474">    Spdu spdu = new Spdu(spduHeader, stamp, sharedMapper.writeValueAsString(sdu));</span>

    // Construire la SIDU
<span class="fc" id="L477">    SiduContext siduContext = new SiduContext(</span>
        session.initiatorId,
        session.peerId,
        session.initiatorIri,
<span class="fc" id="L481">        spduHeader.getId(),</span>
        session.peerIri,
<span class="fc" id="L483">        false);</span>
    String serialSidu;
    try {
<span class="fc" id="L486">      Sidu sidu = new Sidu(siduContext, sharedMapper.writeValueAsString(spdu));</span>
<span class="fc" id="L487">      serialSidu = sharedMapper.writeValueAsString(sidu);</span>
<span class="nc" id="L488">    } catch (JsonProcessingException e) {</span>
<span class="nc" id="L489">      throw new RuntimeException(e);</span>
<span class="fc" id="L490">    }</span>

<span class="fc" id="L492">    session.trackingNumber = siduContext.getTrackingNumber();</span>
<span class="fc" id="L493">    this.sessionInformations.put(session.sessionId, session);</span>

    // Transmettre la IDU à la couche inférieur &amp;&amp; inscrire qu'on attend une réponse pour
    // SES_MSG_ENV
<span class="fc" id="L497">    pendingResponse</span>
<span class="fc" id="L498">        .add(new PendingConfirmation(spduHeader.getId(), session.sessionId, MsgType.SES_MSG_ENV));</span>
<span class="fc" id="L499">    logger.trace(Trace.ALGORITHM_1, serialSidu, serialSidu);</span>

<span class="fc" id="L501">    transportHost.dataRequest(serialSidu);</span>
<span class="fc" id="L502">    transportHost.dataConfirm();</span>

<span class="fc" id="L504">    logger.trace(Trace.EXIT_METHOD_0);</span>
<span class="fc" id="L505">  }</span>

  public PiduAndSession retrieveAnswer(ExpandedSidu expandedSidu) {
<span class="fc" id="L508">    logger.trace(Trace.ENTER_METHOD_1, &quot;expandedSidu&quot;, expandedSidu);</span>

    // Incrémenter le nombre de messages traités avec succès durant la session.
<span class="fc" id="L511">    SesMsgRecDto sesMsgRecDto = null;</span>
    try {
<span class="fc" id="L513">      sesMsgRecDto =</span>
<span class="fc" id="L514">          sharedMapper.readValue((String) expandedSidu.spdu().getContent(), SesMsgRecDto.class);</span>
<span class="nc" id="L515">    } catch (JsonProcessingException e) {</span>
<span class="nc" id="L516">      throw new RuntimeException(e);</span>
<span class="fc" id="L517">    }</span>
<span class="fc" id="L518">    SessionInformation session = sessionInformations.get(new SessionId(sesMsgRecDto.getSession()));</span>
<span class="fc" id="L519">    session.numberOfMessage += 1;</span>
<span class="fc" id="L520">    sessionInformations.put(session.sessionId, session);</span>

    // Transmettre la réponse attendue à la couche supérieure
    // PIDU
    // Transmettre la PIDU à la couche supérieure.
<span class="fc" id="L525">    byte[] keyBytes = session.sdek.getEncoded();</span>
<span class="fc" id="L526">    String serialSdek = Base64.getEncoder().encodeToString(keyBytes);</span>
<span class="fc" id="L527">    PiduContext contextDto = new PiduContext(</span>
        session.pgaId,
        session.initiatorId,
        session.peerId,
        serialSdek,
        session.trackingNumber,
<span class="fc" id="L533">        false);</span>
<span class="fc" id="L534">    Pidu pidu = new Pidu(contextDto, sesMsgRecDto.getContent());</span>

<span class="fc" id="L536">    PiduAndSession piduAndSession = new PiduAndSession(pidu, session);</span>
<span class="fc" id="L537">    logger.trace(Trace.EXIT_METHOD_1, &quot;piduAndSession&quot;, piduAndSession);</span>
<span class="fc" id="L538">    return piduAndSession;</span>
  }

  public void sendClose(PiduAndSession msgResponse) {
<span class="fc" id="L542">    logger.trace(Trace.ENTER_METHOD_1, &quot;msgResponse&quot;, msgResponse);</span>

    // Procéder à l’envoi de la fin de session
    // Créer SDU
<span class="fc" id="L546">    SessionInformation session = msgResponse.sessionInformation();</span>
<span class="fc" id="L547">    UUID token = UUID.randomUUID();</span>

<span class="fc" id="L549">    SessionInformation updatedInfo = SessionInformation.builder()</span>
<span class="fc" id="L550">        .of(session)</span>
<span class="fc" id="L551">        .token(token)</span>
<span class="fc" id="L552">        .build();</span>
<span class="fc" id="L553">    sessionInformations.put(msgResponse.sessionInformation().sessionId, updatedInfo);</span>

<span class="fc" id="L555">    SesFinEnvDto sdu = new SesFinEnvDto(token,</span>
<span class="fc" id="L556">        session.numberOfMessage.toString(), session.sessionId.id());</span>
    String serialSdu;
    try {
<span class="fc" id="L559">      serialSdu = sharedMapper.writeValueAsString(sdu);</span>
<span class="nc" id="L560">    } catch (JsonProcessingException e) {</span>
<span class="nc" id="L561">      throw new RuntimeException(e);</span>
<span class="fc" id="L562">    }</span>

    // Construire la SPDU
<span class="fc" id="L565">    SpduHeader spduHeader = new SpduHeader(HeaderDto.Msgtype.SES_FIN_ENV,</span>
<span class="fc" id="L566">        UUID.randomUUID(),</span>
<span class="fc" id="L567">        false,</span>
        speds);
<span class="fc" id="L569">    String stamp = sealCreator.createSymmetricalSeal(serialSdu, session.skak, sharedMapper);</span>
<span class="fc" id="L570">    Spdu spdu = new Spdu(spduHeader, stamp, serialSdu);</span>

    // Construire la SIDU
<span class="fc" id="L573">    SiduContext siduContext = new SiduContext(</span>
        session.initiatorId,
        session.peerId,
        session.initiatorIri,
<span class="fc" id="L577">        spdu.getHeader().getId(),</span>
        session.peerIri,
<span class="fc" id="L579">        false);</span>

    try {
<span class="fc" id="L582">      Sidu sidu = new Sidu(siduContext, sharedMapper.writeValueAsString(spdu));</span>
<span class="fc" id="L583">      String serialSidu = sharedMapper.writeValueAsString(sidu);</span>
<span class="fc" id="L584">      pendingResponse.add(new PendingConfirmation(token, session.sessionId,</span>
          MsgType.SES_FIN_ENV));
<span class="fc" id="L586">      logger.trace(Trace.ALGORITHM_1, &quot;serialSidu&quot;, serialSidu);</span>

<span class="fc" id="L588">      transportHost.dataRequest(serialSidu);</span>
<span class="fc" id="L589">      transportHost.dataConfirm();</span>
<span class="nc" id="L590">    } catch (JsonProcessingException e) {</span>
<span class="nc" id="L591">      throw new RuntimeException(e);</span>
<span class="fc" id="L592">    }</span>

<span class="fc" id="L594">    logger.trace(Trace.EXIT_METHOD_0);</span>
<span class="fc" id="L595">  }</span>

  public void closeSession(ExpandedSidu expandedSidu) {
<span class="fc" id="L598">    logger.trace(Trace.ENTER_METHOD_1, &quot;expandedSidu&quot;, expandedSidu);</span>
    // Supprimer du Tableau des réponses en attente, l’entrée de SES.FIN.ENV d’identifiant id.

    SesFinRecDto sdu;
    try {
<span class="fc" id="L603">      sdu = sharedMapper.readValue((String) expandedSidu.spdu().getContent(), SesFinRecDto.class);</span>
<span class="nc" id="L604">    } catch (JsonProcessingException e) {</span>
<span class="nc" id="L605">      throw new DeserializationException(e);</span>
<span class="fc" id="L606">    }</span>

<span class="fc" id="L608">    PendingConfirmation match = this.pendingResponse.stream()</span>
<span class="fc" id="L609">        .filter(x -&gt; x.uniqueId().equals(sdu.getToken()))</span>
<span class="fc" id="L610">        .findFirst()</span>
<span class="fc" id="L611">        .orElseThrow(() -&gt; new SessionTerminaisonFailedException(&quot;Element not found&quot;));</span>
<span class="fc" id="L612">    this.pendingResponse.remove(match);</span>
<span class="fc" id="L613">    SessionInformation session = this.sessionInformations.get(match.sessionId());</span>

    // Retirer les informations de session
<span class="fc" id="L616">    this.sessionInformations.remove(session.sessionId);</span>

    // Vérifier la correspondance avec le message d'envoi
<span class="pc bpc" id="L619" title="1 of 2 branches missed.">    if (!sdu.getToken().equals(match.uniqueId())) {</span>
<span class="nc" id="L620">      throw new SessionTerminaisonFailedException(&quot;Token does not match original token - &quot;</span>
<span class="nc" id="L621">          + &quot;orignal=&quot; + match.uniqueId() + &quot; response=&quot; + sdu.getToken());</span>
    }

<span class="fc" id="L624">    logger.trace(Trace.EXIT_METHOD_0);</span>
<span class="fc" id="L625">  }</span>

  public void loadSessionState() {
    // TODO
<span class="nc" id="L629">  }</span>

  public void saveSessionState() {
    // TODO
<span class="fc" id="L633">  }</span>

  public Map&lt;SessionId, SessionInformation&gt; getSessionInfo() {
<span class="fc" id="L636">    return Map.copyOf(this.sessionInformations);</span>
  }

  public ConcurrentLinkedQueue&lt;PendingConfirmation&gt; getPendingResponse() {
<span class="nc" id="L640">    return pendingResponse;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>