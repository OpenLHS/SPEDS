<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ClientSession.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">speds-session-library</a> &gt; <a href="index.source.html" class="el_package">ca.griis.speds.session.internal.service</a> &gt; <span class="el_source">ClientSession.java</span></div><h1>ClientSession.java</h1><pre class="source lang-java linenums">/**
 * @file
 *
 * @copyright @@GRIIS_COPYRIGHT@@
 *
 * @licence @@GRIIS_LICENCE@@
 *
 * @version @@GRIIS_VERSION@@
 *
 * @brief @~french Implémentation de la classe ClientSession.
 * @brief @~english Implementation of the ClientSession class.
 */

package ca.griis.speds.session.internal.service;

import ca.griis.cryptography.asymmetric.keypair.CertificatePrivateKeysEntry;
import ca.griis.cryptography.symmetric.encryption.AesGcmDecryptor;
import ca.griis.cryptography.symmetric.encryption.AesGcmEncryptor;
import ca.griis.js2p.gen.speds.session.api.dto.HeaderDto;
import ca.griis.js2p.gen.speds.session.api.dto.InterfaceDataUnit23Dto;
import ca.griis.js2p.gen.speds.session.api.dto.SPEDSDto;
import ca.griis.js2p.gen.speds.session.api.dto.cle.KeyTransferDto;
import ca.griis.js2p.gen.speds.session.api.dto.cle.SesCleEnvDto;
import ca.griis.js2p.gen.speds.session.api.dto.cle.SesCleRecDto;
import ca.griis.js2p.gen.speds.session.api.dto.fin.SesFinEnvDto;
import ca.griis.js2p.gen.speds.session.api.dto.fin.SesFinRecDto;
import ca.griis.js2p.gen.speds.session.api.dto.msg.SesMsgEnvDto;
import ca.griis.js2p.gen.speds.session.api.dto.msg.SesMsgRecDto;
import ca.griis.js2p.gen.speds.session.api.dto.sak.SesSakEnvDto;
import ca.griis.js2p.gen.speds.session.api.dto.sak.SesSakRecDto;
import ca.griis.logger.GriisLogger;
import ca.griis.logger.GriisLoggerFactory;
import ca.griis.logger.statuscode.Debug;
import ca.griis.logger.statuscode.Trace;
import ca.griis.speds.session.api.PgaService;
import ca.griis.speds.session.api.exception.DeserializationException;
import ca.griis.speds.session.api.exception.InvalidTokenException;
import ca.griis.speds.session.api.exception.SessionTerminaisonFailedException;
import ca.griis.speds.session.internal.contract.MsgType;
import ca.griis.speds.session.internal.contract.Pidu;
import ca.griis.speds.session.internal.contract.PiduContext;
import ca.griis.speds.session.internal.contract.SesPubEnvDto;
import ca.griis.speds.session.internal.contract.Sidu;
import ca.griis.speds.session.internal.contract.SiduContext;
import ca.griis.speds.session.internal.contract.Spdu;
import ca.griis.speds.session.internal.contract.SpduHeader;
import ca.griis.speds.session.internal.domain.ExpandedSidu;
import ca.griis.speds.session.internal.domain.HostStartupContext;
import ca.griis.speds.session.internal.domain.PiduAndSession;
import ca.griis.speds.session.internal.domain.SessionId;
import ca.griis.speds.session.internal.handler.HandlerRegistry;
import ca.griis.speds.session.internal.handler.initiator.InitiatorHandlerRegistry;
import ca.griis.speds.session.internal.model.PendingConfirmation;
import ca.griis.speds.session.internal.model.SessionInformation;
import ca.griis.speds.session.internal.processing.Poller;
import ca.griis.speds.session.internal.service.crypto.KeyAgreement;
import ca.griis.speds.session.internal.service.seal.SealCreator;
import ca.griis.speds.session.internal.util.KeyAlgorithm;
import ca.griis.speds.session.internal.util.KeyMapping;
import ca.griis.speds.transport.api.TransportHost;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.nio.charset.StandardCharsets;
import java.security.KeyPair;
import java.security.PublicKey;
import java.time.Duration;
import java.util.Base64;
import java.util.Map;
import java.util.Objects;
import java.util.UUID;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.LinkedBlockingDeque;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;

/**
 * @brief @~english «Brief component description (class, interface, ...)»
 * @par Details
 *      «Detailed description of the component (optional)»
 * @par Model
 *      «Model (Abstract, automation, etc.) (optional)»
 * @par Conception
 *      «Conception description (criteria and constraints) (optional)»
 * @par Limits
 *      «Limits description (optional)»
 *
 * @brief @~french Implémente la logique métier d’un client gérant la couche session
 * @par Details
 *      S.O.
 * @par Modèle
 *      S.O.
 * @par Conception
 *      S.O.
 * @par Limites
 *      S.O.
 *
 * @par Historique
 *      2025-03-17 [SSC] - Implémentation initiale&lt;br&gt;
 *      2025-05-14 [CB] - Refact - itération 2&lt;br&gt;
 *      2025-06-29 [MD] - Refact - itération 4&lt;br&gt;
 *
 * @par Tâches
 *      S.O.
 */
public final class ClientSession {
<span class="fc" id="L110">  private static final GriisLogger logger = GriisLoggerFactory.getLogger(ClientSession.class);</span>

<span class="fc" id="L112">  private static final ExpandedSidu poisonPill = new ExpandedSidu(null, null, null);</span>

  private final PgaService pgaService;
  private final ObjectMapper sharedMapper;
  private final SealCreator sealCreator;
  private final SPEDSDto speds;
  private final TransportHost transportHost;
  private final Poller poller;

  private final ConcurrentLinkedQueue&lt;PendingConfirmation&gt; pendingResponse;
  private final BlockingQueue&lt;ExpandedSidu&gt; messageWeHandle;
  private final Map&lt;SessionId, SessionInformation&gt; sessionInformations;
  private final CertificatePrivateKeysEntry hostCertificate;
  private final Duration clientTimeout;
  private final LinkedBlockingQueue&lt;InterfaceDataUnit23Dto&gt; pidus;

  public ClientSession(HostStartupContext hostStartupContext, Poller poller,
<span class="fc" id="L129">      LinkedBlockingQueue&lt;InterfaceDataUnit23Dto&gt; pidus) {</span>
<span class="fc" id="L130">    logger.trace(Trace.ENTER_METHOD_2, &quot;hostStartupContext&quot;, hostStartupContext, &quot;poller&quot;, poller);</span>
<span class="fc" id="L131">    this.messageWeHandle = new LinkedBlockingDeque&lt;&gt;();</span>
<span class="fc" id="L132">    this.pendingResponse = new ConcurrentLinkedQueue&lt;&gt;();</span>
<span class="fc" id="L133">    this.pidus = pidus;</span>
<span class="fc" id="L134">    this.pgaService = hostStartupContext.pgaService();</span>
<span class="fc" id="L135">    this.sessionInformations = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L136">    this.hostCertificate = hostStartupContext.hostKeys();</span>
<span class="fc" id="L137">    this.sharedMapper = hostStartupContext.sharedMapper();</span>
<span class="fc" id="L138">    this.speds = hostStartupContext.spedsDto();</span>
<span class="fc" id="L139">    this.transportHost = hostStartupContext.transportHost();</span>
<span class="fc" id="L140">    this.clientTimeout = hostStartupContext.responseTimeout();</span>
<span class="fc" id="L141">    this.poller = poller;</span>
<span class="fc" id="L142">    HandlerRegistry handlerRegistry = new InitiatorHandlerRegistry(sharedMapper, pgaService,</span>
        messageWeHandle, sessionInformations);
<span class="fc" id="L144">    this.poller.registerHandlers(handlerRegistry);</span>
<span class="fc" id="L145">    this.sealCreator = new SealCreator();</span>
<span class="fc" id="L146">  }</span>

  public void close() {
<span class="fc" id="L149">    closePreservingSessionStates();</span>
<span class="fc" id="L150">    sessionInformations.clear();</span>
<span class="fc" id="L151">  }</span>

  public void closePreservingSessionStates() {
<span class="fc" id="L154">    saveSessionState();</span>

<span class="fc" id="L156">    poller.stop();</span>
<span class="fc" id="L157">    transportHost.close();</span>
<span class="fc" id="L158">    pendingResponse.clear();</span>
<span class="fc" id="L159">    messageWeHandle.clear();</span>

    try {
<span class="fc" id="L162">      messageWeHandle.put(poisonPill);</span>
<span class="nc" id="L163">    } catch (InterruptedException e) {</span>
<span class="nc" id="L164">      Thread.currentThread().interrupt();</span>
<span class="fc" id="L165">    }</span>
<span class="fc" id="L166">  }</span>

  public void clearSessionStates() {
<span class="fc" id="L169">    sessionInformations.clear();</span>
<span class="fc" id="L170">  }</span>

  public void sendMessageWithManagedSession(Pidu pidu) throws JsonProcessingException {
<span class="fc" id="L173">    logger.trace(Trace.ENTER_METHOD_1, &quot;pidu&quot;, pidu);</span>

    // init a session
<span class="fc" id="L176">    SessionId sessionId = new SessionId(UUID.randomUUID());</span>

<span class="fc" id="L178">    PublicKey publicKey = hostCertificate.getCertficate().getPublicKey();</span>
<span class="fc" id="L179">    final String initiatorPubKey = Base64.getEncoder().encodeToString(publicKey.getEncoded());</span>
<span class="fc" id="L180">    final String initiatorIri = pgaService.getIri(pidu.getContext().getPga(),</span>
<span class="fc" id="L181">        pidu.getContext().getSourceCode());</span>
<span class="fc" id="L182">    final String peerIri = pgaService.getIri(pidu.getContext().getPga(),</span>
<span class="fc" id="L183">        pidu.getContext().getDestinationCode());</span>

<span class="fc" id="L185">    byte[] keyBytes = Base64.getDecoder().decode(pidu.getContext().getSdek());</span>
<span class="fc" id="L186">    SecretKey secretKey = new SecretKeySpec(keyBytes, 0, keyBytes.length, &quot;AES&quot;);</span>

<span class="fc" id="L188">    SessionInformation sessionInfo = SessionInformation.builder()</span>
<span class="fc" id="L189">        .sessionId(sessionId)</span>
<span class="fc" id="L190">        .initiatorId(pidu.getContext().getSourceCode())</span>
<span class="fc" id="L191">        .initiatorIri(initiatorIri)</span>
<span class="fc" id="L192">        .initiatorPubKey(initiatorPubKey)</span>
<span class="fc" id="L193">        .sdek(secretKey)</span>
<span class="fc" id="L194">        .trackingNumber(pidu.getContext().getTrackingNumber())</span>
<span class="fc" id="L195">        .peerId(pidu.getContext().getDestinationCode())</span>
<span class="fc" id="L196">        .peerIri(peerIri)</span>
<span class="fc" id="L197">        .piduMessage(pidu.getMessage())</span>
<span class="fc" id="L198">        .pgaId(pidu.getContext().getPga())</span>
<span class="fc" id="L199">        .numberOfMessage(0)</span>
<span class="fc" id="L200">        .build();</span>
<span class="fc" id="L201">    this.sessionInformations.put(sessionId, sessionInfo);</span>

    // call initSession
<span class="fc" id="L204">    sendPubEnv(pidu, sessionId);</span>

<span class="fc bfc" id="L206" title="All 2 branches covered.">    while (!pendingResponse.isEmpty()) {</span>
      try {
<span class="fc" id="L208">        ExpandedSidu expandedSidu =</span>
<span class="fc" id="L209">            messageWeHandle.poll(clientTimeout.getSeconds(), TimeUnit.SECONDS);</span>
<span class="fc" id="L210">        Objects.requireNonNull(expandedSidu);</span>

<span class="pc bpc" id="L212" title="1 of 2 branches missed.">        if (!expandedSidu.equals(poisonPill)) {</span>
<span class="fc" id="L213">          handleSession(expandedSidu);</span>
        } else {
<span class="nc" id="L215">          pendingResponse.clear();</span>
<span class="nc" id="L216">          logger.debug(Debug.VARIABLE_LOGGING_1, &quot;poisonPill&quot;, poisonPill);</span>
        }
<span class="nc" id="L218">      } catch (InterruptedException e) {</span>
<span class="nc" id="L219">        Thread.currentThread().interrupt();</span>
<span class="pc" id="L220">      }</span>
    }

<span class="fc" id="L223">    logger.trace(Trace.EXIT_METHOD_0);</span>
<span class="fc" id="L224">  }</span>

  private void handleSession(ExpandedSidu expandedSidu) throws JsonProcessingException {
<span class="fc" id="L227">    PiduAndSession msgResponse = null;</span>
<span class="pc bpc" id="L228" title="1 of 6 branches missed.">    switch (expandedSidu.msgType()) {</span>
<span class="fc" id="L229">      case SES_PUB_REC -&gt; sendSkak(expandedSidu);</span>
<span class="fc" id="L230">      case SES_SAK_REC -&gt; sendSdek(expandedSidu);</span>
<span class="fc" id="L231">      case SES_CLE_REC -&gt; sendMsg(expandedSidu);</span>
<span class="fc" id="L232">      case SES_MSG_REC -&gt; msgResponse = retrieveAnswer(expandedSidu);</span>
<span class="fc" id="L233">      case SES_FIN_REC -&gt; closeSession(expandedSidu);</span>
<span class="nc" id="L234">      default -&gt; throw new IllegalArgumentException(&quot;Unexpected message type: &quot;</span>
<span class="nc" id="L235">          + expandedSidu.msgType());</span>
    }

<span class="fc bfc" id="L238" title="All 2 branches covered.">    if (msgResponse != null) {</span>
      // Supprimer du Tableau des réponses en attente, l’entrée de SES.MSG.ENV d’identifiant
      // id.
<span class="fc" id="L241">      PendingConfirmation match = this.pendingResponse.stream()</span>
<span class="fc" id="L242">          .filter(x -&gt; x.uniqueId().equals(expandedSidu.spdu().getHeader().getId()))</span>
<span class="fc" id="L243">          .findFirst()</span>
<span class="pc" id="L244">          .orElseThrow(() -&gt; new IllegalStateException(&quot;Element not found&quot;));</span>
<span class="fc" id="L245">      this.pendingResponse.remove(match);</span>

      // Session is done we close
<span class="fc" id="L248">      sendClose(msgResponse);</span>
    }
<span class="fc" id="L250">  }</span>

  public void sendPubEnv(Pidu pidu, SessionId sessionId) {
<span class="fc" id="L253">    logger.trace(Trace.ENTER_METHOD_2, &quot;pidu&quot;, pidu, &quot;sessionId&quot;, sessionId);</span>

<span class="fc" id="L255">    SessionInformation currentSession = this.sessionInformations.get(sessionId);</span>

    // Créer une SDU SES.PUB.ENV pour transmettre la clé publique avec le numéro de la session

    // Créer une SDU de type SES_PUB_ENV
<span class="fc" id="L260">    String pubKey = currentSession.initiatorPubKey;</span>
<span class="fc" id="L261">    SesPubEnvDto sesPubEnvDto = new SesPubEnvDto(pubKey, currentSession.sessionId.id());</span>

    // Construire la SPDU
<span class="fc" id="L264">    SpduHeader spduHeader = new SpduHeader(HeaderDto.Msgtype.SES_PUB_ENV, UUID.randomUUID(),</span>
<span class="fc" id="L265">        false,</span>
        speds);
<span class="fc" id="L267">    Spdu spdu = null;</span>
    try {
<span class="fc" id="L269">      spdu = new Spdu(spduHeader, &quot;0&quot;, sharedMapper.writeValueAsString(sesPubEnvDto));</span>
<span class="nc" id="L270">    } catch (JsonProcessingException e) {</span>
<span class="nc" id="L271">      throw new RuntimeException(e);</span>
<span class="fc" id="L272">    }</span>

    // Construire le SIDU
<span class="fc" id="L275">    String sourceIri = currentSession.initiatorIri;</span>
<span class="fc" id="L276">    String destinationIri = currentSession.peerIri;</span>
<span class="fc" id="L277">    SiduContext siduContext = new SiduContext(</span>
<span class="fc" id="L278">        pidu.getContext().getSourceCode(),</span>
<span class="fc" id="L279">        pidu.getContext().getDestinationCode(),</span>
        sourceIri,
<span class="fc" id="L281">        spduHeader.getId(),</span>
        destinationIri,
<span class="fc" id="L283">        false);</span>

    String serialSidu;
    try {
<span class="fc" id="L287">      Sidu sidu = new Sidu(siduContext, sharedMapper.writeValueAsString(spdu));</span>
<span class="fc" id="L288">      serialSidu = sharedMapper.writeValueAsString(sidu);</span>
<span class="nc" id="L289">    } catch (JsonProcessingException e) {</span>
<span class="nc" id="L290">      throw new RuntimeException(e);</span>
<span class="fc" id="L291">    }</span>

    // Transmettre la IDU à la couche inférieure et attendre qu’une réponse de type [SES.PUB.REC] et
    // d’identifiant le id
<span class="fc" id="L295">    pendingResponse</span>
<span class="fc" id="L296">        .add(new PendingConfirmation(spduHeader.getId(), sessionId, MsgType.SES_PUB_ENV));</span>

<span class="fc" id="L298">    logger.trace(Trace.ALGORITHM_1, &quot;serialSidu&quot;, serialSidu);</span>

<span class="fc" id="L300">    transportHost.dataRequest(serialSidu);</span>
<span class="fc" id="L301">    transportHost.dataConfirm();</span>

<span class="fc" id="L303">    logger.trace(Trace.EXIT_METHOD_0);</span>
<span class="fc" id="L304">  }</span>

  public void sendSkak(ExpandedSidu expandedSidu) throws JsonProcessingException {
    // Supprimer du Tableau des réponses en attente, l’entrée de SES.PUB.ENV d’identifiant id.
<span class="fc" id="L308">    PendingConfirmation match = this.pendingResponse.stream()</span>
<span class="fc" id="L309">        .filter(x -&gt; x.uniqueId().equals(expandedSidu.spdu().getHeader().getId()))</span>
<span class="fc" id="L310">        .findFirst()</span>
<span class="pc" id="L311">        .orElseThrow(() -&gt; new IllegalStateException(&quot;Element not found&quot;));</span>
<span class="fc" id="L312">    this.pendingResponse.remove(match);</span>
<span class="fc" id="L313">    SessionInformation session = this.sessionInformations.get(match.sessionId());</span>

    // Créer une SDU de type SES.SAK.ENV
    // Déterminer le choix de la clef
<span class="fc" id="L317">    KeyAgreement keyAgreement = new KeyAgreement();</span>
<span class="fc" id="L318">    KeyPair choiceKeyPair = keyAgreement.generateChoicePointKey();</span>
<span class="fc" id="L319">    String choice = Base64.getEncoder().encodeToString(choiceKeyPair.getPublic().getEncoded());</span>
<span class="fc" id="L320">    String serialId = session.sessionId.id().toString();</span>
<span class="fc" id="L321">    SesSakEnvDto sdu = new SesSakEnvDto(choice, serialId);</span>
<span class="fc" id="L322">    String serialSdu = sharedMapper.writeValueAsString(sdu);</span>
<span class="fc" id="L323">    session.firstChoice = choiceKeyPair;</span>

    // Construire la SPDU
<span class="fc" id="L326">    SpduHeader spduHeader = new SpduHeader(HeaderDto.Msgtype.SES_SAK_ENV, UUID.randomUUID(),</span>
<span class="fc" id="L327">        false, speds);</span>
<span class="fc" id="L328">    String stamp = sealCreator.createSeal(serialSdu, hostCertificate.getPrivateKey(), sharedMapper);</span>
<span class="fc" id="L329">    Spdu spdu = new Spdu(spduHeader, stamp, serialSdu);</span>

    // Construire le SIDU
<span class="fc" id="L332">    SiduContext siduContext = new SiduContext(</span>
        session.initiatorId,
        session.peerId,
        session.initiatorIri,
<span class="fc" id="L336">        spduHeader.getId(),</span>
        session.peerIri,
<span class="fc" id="L338">        false);</span>
    String serialSidu;
    try {
<span class="fc" id="L341">      Sidu sidu = new Sidu(siduContext, sharedMapper.writeValueAsString(spdu));</span>
<span class="fc" id="L342">      serialSidu = sharedMapper.writeValueAsString(sidu);</span>
<span class="nc" id="L343">    } catch (JsonProcessingException e) {</span>
<span class="nc" id="L344">      throw new RuntimeException(e);</span>
<span class="fc" id="L345">    }</span>

    // Transmettre la IDU à la couche inférieure &amp;&amp; inscrire qu'on attend une réponse pour
    // SES_SAK_ENV
<span class="fc" id="L349">    pendingResponse</span>
<span class="fc" id="L350">        .add(new PendingConfirmation(spduHeader.getId(), session.sessionId, MsgType.SES_SAK_ENV));</span>

<span class="fc" id="L352">    transportHost.dataRequest(serialSidu);</span>
<span class="fc" id="L353">    transportHost.dataConfirm();</span>

<span class="fc" id="L355">    logger.trace(Trace.EXIT_METHOD_0);</span>
<span class="fc" id="L356">  }</span>

  public void sendSdek(ExpandedSidu expandedSidu) throws JsonProcessingException {
    // Supprimer du Tableau des réponses en attente, l’entrée de SES.SAK.ENV d’identifiant id.
<span class="fc" id="L360">    PendingConfirmation match = this.pendingResponse.stream()</span>
<span class="fc" id="L361">        .filter(x -&gt; x.uniqueId().equals(expandedSidu.spdu().getHeader().getId()))</span>
<span class="fc" id="L362">        .findFirst()</span>
<span class="pc" id="L363">        .orElseThrow(() -&gt; new IllegalStateException(&quot;Element not found&quot;));</span>
<span class="fc" id="L364">    this.pendingResponse.remove(match);</span>
<span class="fc" id="L365">    SessionInformation session = this.sessionInformations.get(match.sessionId());</span>

    // Déterminer / mémoriser SKAK
<span class="fc" id="L368">    KeyAgreement keyAgreement = new KeyAgreement();</span>
<span class="fc" id="L369">    SesSakRecDto sesSakRecDto =</span>
<span class="fc" id="L370">        sharedMapper.readValue((String) expandedSidu.spdu().getContent(), SesSakRecDto.class);</span>
<span class="fc" id="L371">    PublicKey peerChoice =</span>
<span class="fc" id="L372">        KeyMapping.getPublicKeyFromString(sesSakRecDto.getValue(), KeyAlgorithm.X25519);</span>
<span class="fc" id="L373">    byte[] skakByte = keyAgreement.completeKeyAgreementNegotiation(session.firstChoice,</span>
        peerChoice);
<span class="fc" id="L375">    SecretKey skak = KeyMapping.getAesSecretKeyFromByte(skakByte);</span>
<span class="fc" id="L376">    session.skak = skak;</span>

<span class="fc" id="L378">    UUID sessionToken = UUID.randomUUID();</span>
<span class="fc" id="L379">    SessionInformation updatedInfo = SessionInformation.builder()</span>
<span class="fc" id="L380">        .of(session)</span>
<span class="fc" id="L381">        .token(sessionToken)</span>
<span class="fc" id="L382">        .build();</span>
<span class="fc" id="L383">    sessionInformations.put(match.sessionId(), updatedInfo);</span>

    // Procéder à l’envoi de la clé de chiffrement SDEK
    // Créer SDU
<span class="fc" id="L387">    byte[] keyBytes = session.sdek.getEncoded();</span>
<span class="fc" id="L388">    String serialKey = Base64.getEncoder().encodeToString(keyBytes);</span>
<span class="fc" id="L389">    KeyTransferDto keyTransferDto = new KeyTransferDto(serialKey, session.pgaId, sessionToken);</span>
<span class="fc" id="L390">    AesGcmEncryptor symmetricEncrypt = new AesGcmEncryptor(skak);</span>
<span class="fc" id="L391">    byte[] cryptedKeyTrans =</span>
<span class="fc" id="L392">        symmetricEncrypt.encrypt(sharedMapper.writeValueAsBytes(keyTransferDto));</span>
<span class="fc" id="L393">    String serialKeyTrans = Base64.getEncoder().encodeToString(cryptedKeyTrans);</span>
<span class="fc" id="L394">    SesCleEnvDto sdu = new SesCleEnvDto(serialKeyTrans, session.sessionId.id());</span>

    // Construire la SPDU
<span class="fc" id="L397">    SpduHeader spduHeader = new SpduHeader(HeaderDto.Msgtype.SES_CLE_ENV,</span>
<span class="fc" id="L398">        UUID.randomUUID(), false, speds);</span>

<span class="fc" id="L400">    String stamp = sealCreator.createSymmetricalSeal(sdu, skak, sharedMapper);</span>
<span class="fc" id="L401">    Spdu spdu = new Spdu(spduHeader, stamp, sharedMapper.writeValueAsString(sdu));</span>

    // Construire la SIDU
<span class="fc" id="L404">    SiduContext siduContext = new SiduContext(</span>
        session.initiatorId,
        session.peerId,
        session.initiatorIri,
<span class="fc" id="L408">        spdu.getHeader().getId(),</span>
        session.peerIri,
<span class="fc" id="L410">        false);</span>
    String serialSidu;
    try {
<span class="fc" id="L413">      Sidu sidu = new Sidu(siduContext, sharedMapper.writeValueAsString(spdu));</span>
<span class="fc" id="L414">      serialSidu = sharedMapper.writeValueAsString(sidu);</span>
<span class="nc" id="L415">    } catch (JsonProcessingException e) {</span>
<span class="nc" id="L416">      throw new RuntimeException(e);</span>
<span class="fc" id="L417">    }</span>

    // Transmettre la IDU à la couche inférieur &amp;&amp; inscrire qu'on attend une réponse pour
    // SES_CLE_ENV
<span class="fc" id="L421">    pendingResponse</span>
<span class="fc" id="L422">        .add(new PendingConfirmation(spduHeader.getId(), session.sessionId, MsgType.SES_CLE_ENV));</span>
<span class="fc" id="L423">    logger.trace(Trace.ALGORITHM_1, serialSidu, serialSidu);</span>

<span class="fc" id="L425">    transportHost.dataRequest(serialSidu);</span>
<span class="fc" id="L426">    transportHost.dataConfirm();</span>

<span class="fc" id="L428">    logger.trace(Trace.EXIT_METHOD_0);</span>
<span class="fc" id="L429">  }</span>

  public void sendMsg(ExpandedSidu expandedSidu) throws JsonProcessingException {
<span class="fc" id="L432">    logger.trace(Trace.ENTER_METHOD_1, &quot;expandedSidu&quot;, expandedSidu);</span>

    // Supprimer du Tableau des réponses en attente, l’entrée de SES.CLE.ENV d’identifiant id.
<span class="fc" id="L435">    PendingConfirmation match = this.pendingResponse.stream()</span>
<span class="fc" id="L436">        .filter(x -&gt; x.uniqueId().equals(expandedSidu.spdu().getHeader().getId()))</span>
<span class="fc" id="L437">        .findFirst()</span>
<span class="pc" id="L438">        .orElseThrow(() -&gt; new IllegalStateException(&quot;Element not found&quot;));</span>
<span class="fc" id="L439">    this.pendingResponse.remove(match);</span>
<span class="fc" id="L440">    SessionInformation session = this.sessionInformations.get(match.sessionId());</span>
<span class="fc" id="L441">    SesCleRecDto sesCleRecDto =</span>
<span class="fc" id="L442">        sharedMapper.readValue((String) expandedSidu.spdu().getContent(), SesCleRecDto.class);</span>

    try {
<span class="fc" id="L445">      byte[] encryptedToken = Base64.getDecoder().decode(sesCleRecDto.getContent());</span>
<span class="fc" id="L446">      AesGcmDecryptor aesGcmDecryptor = new AesGcmDecryptor(session.sdek);</span>
<span class="fc" id="L447">      byte[] decryptedToken = aesGcmDecryptor.decrypt(encryptedToken);</span>
<span class="fc" id="L448">      UUID token = UUID.fromString(new String(decryptedToken, StandardCharsets.UTF_8));</span>
<span class="pc bpc" id="L449" title="1 of 2 branches missed.">      if (token.compareTo(session.token) != 0) {</span>
<span class="nc" id="L450">        throw new InvalidTokenException(&quot;Token is invalid&quot;);</span>
      }
<span class="fc" id="L452">    } catch (Exception e) {</span>
<span class="fc" id="L453">      throw new InvalidTokenException(&quot;Impossible to retrieve the token&quot;);</span>
<span class="fc" id="L454">    }</span>

    // Procéder à l’envoi du message à transmettre
    // Créer une SDU SES.MSG.ENV
<span class="fc" id="L458">    SesMsgEnvDto sdu = new SesMsgEnvDto(session.piduMessage, session.sessionId.id());</span>

    // Construire la SPDU
<span class="fc" id="L461">    SpduHeader spduHeader = new SpduHeader(HeaderDto.Msgtype.SES_MSG_ENV,</span>
<span class="fc" id="L462">        UUID.randomUUID(),</span>
<span class="fc" id="L463">        false,</span>
        speds);
<span class="fc" id="L465">    String stamp = sealCreator.createSymmetricalSeal(sdu, session.skak, sharedMapper);</span>
<span class="fc" id="L466">    Spdu spdu = new Spdu(spduHeader, stamp, sharedMapper.writeValueAsString(sdu));</span>

    // Construire la SIDU
<span class="fc" id="L469">    SiduContext siduContext = new SiduContext(</span>
        session.initiatorId,
        session.peerId,
        session.initiatorIri,
<span class="fc" id="L473">        spduHeader.getId(),</span>
        session.peerIri,
<span class="fc" id="L475">        false);</span>
    String serialSidu;
    try {
<span class="fc" id="L478">      Sidu sidu = new Sidu(siduContext, sharedMapper.writeValueAsString(spdu));</span>
<span class="fc" id="L479">      serialSidu = sharedMapper.writeValueAsString(sidu);</span>
<span class="nc" id="L480">    } catch (JsonProcessingException e) {</span>
<span class="nc" id="L481">      throw new RuntimeException(e);</span>
<span class="fc" id="L482">    }</span>

<span class="fc" id="L484">    this.sessionInformations.put(session.sessionId, session);</span>

    // Transmettre la IDU à la couche inférieur &amp;&amp; inscrire qu'on attend une réponse pour
    // SES_MSG_ENV
<span class="fc" id="L488">    pendingResponse</span>
<span class="fc" id="L489">        .add(new PendingConfirmation(spduHeader.getId(), session.sessionId, MsgType.SES_MSG_ENV));</span>
<span class="fc" id="L490">    logger.trace(Trace.ALGORITHM_1, serialSidu, serialSidu);</span>

<span class="fc" id="L492">    transportHost.dataRequest(serialSidu);</span>
<span class="fc" id="L493">    transportHost.dataConfirm();</span>

<span class="fc" id="L495">    logger.trace(Trace.EXIT_METHOD_0);</span>
<span class="fc" id="L496">  }</span>

  public PiduAndSession retrieveAnswer(ExpandedSidu expandedSidu) {
<span class="fc" id="L499">    logger.trace(Trace.ENTER_METHOD_1, &quot;expandedSidu&quot;, expandedSidu);</span>

    // Incrémenter le nombre de messages traités avec succès durant la session.
<span class="fc" id="L502">    SesMsgRecDto sesMsgRecDto = null;</span>
    try {
<span class="fc" id="L504">      sesMsgRecDto =</span>
<span class="fc" id="L505">          sharedMapper.readValue((String) expandedSidu.spdu().getContent(), SesMsgRecDto.class);</span>
<span class="nc" id="L506">    } catch (JsonProcessingException e) {</span>
<span class="nc" id="L507">      throw new RuntimeException(e);</span>
<span class="fc" id="L508">    }</span>
<span class="fc" id="L509">    SessionInformation session = sessionInformations.get(new SessionId(sesMsgRecDto.getSession()));</span>
<span class="fc" id="L510">    session.numberOfMessage += 1;</span>
<span class="fc" id="L511">    sessionInformations.put(session.sessionId, session);</span>

    // Transmettre la réponse attendue à la couche supérieure
    // PIDU
    // Transmettre la PIDU à la couche supérieure.
<span class="fc" id="L516">    byte[] keyBytes = session.sdek.getEncoded();</span>
<span class="fc" id="L517">    String serialSdek = Base64.getEncoder().encodeToString(keyBytes);</span>
<span class="fc" id="L518">    PiduContext contextDto = new PiduContext(</span>
        session.pgaId,
        session.initiatorId,
        session.peerId,
        serialSdek,
        session.trackingNumber,
<span class="fc" id="L524">        false);</span>
<span class="fc" id="L525">    Pidu pidu = new Pidu(contextDto, sesMsgRecDto.getContent());</span>
<span class="fc" id="L526">    pidus.add(pidu);</span>

<span class="fc" id="L528">    PiduAndSession piduAndSession = new PiduAndSession(pidu, session);</span>
<span class="fc" id="L529">    logger.trace(Trace.EXIT_METHOD_1, &quot;piduAndSession&quot;, piduAndSession);</span>
<span class="fc" id="L530">    return piduAndSession;</span>
  }

  public void sendClose(PiduAndSession msgResponse) {
<span class="fc" id="L534">    logger.trace(Trace.ENTER_METHOD_1, &quot;msgResponse&quot;, msgResponse);</span>

    // Procéder à l’envoi de la fin de session
    // Créer SDU
<span class="fc" id="L538">    SessionInformation session = msgResponse.sessionInformation();</span>
<span class="fc" id="L539">    UUID token = UUID.randomUUID();</span>

<span class="fc" id="L541">    SessionInformation updatedInfo = SessionInformation.builder()</span>
<span class="fc" id="L542">        .of(session)</span>
<span class="fc" id="L543">        .token(token)</span>
<span class="fc" id="L544">        .build();</span>
<span class="fc" id="L545">    sessionInformations.put(msgResponse.sessionInformation().sessionId, updatedInfo);</span>

<span class="fc" id="L547">    SesFinEnvDto sdu = new SesFinEnvDto(token,</span>
<span class="fc" id="L548">        session.numberOfMessage.toString(), session.sessionId.id());</span>
    String serialSdu;
    try {
<span class="fc" id="L551">      serialSdu = sharedMapper.writeValueAsString(sdu);</span>
<span class="nc" id="L552">    } catch (JsonProcessingException e) {</span>
<span class="nc" id="L553">      throw new RuntimeException(e);</span>
<span class="fc" id="L554">    }</span>

    // Construire la SPDU
<span class="fc" id="L557">    SpduHeader spduHeader = new SpduHeader(HeaderDto.Msgtype.SES_FIN_ENV,</span>
<span class="fc" id="L558">        UUID.randomUUID(),</span>
<span class="fc" id="L559">        false,</span>
        speds);
<span class="fc" id="L561">    String stamp = sealCreator.createSymmetricalSeal(serialSdu, session.skak, sharedMapper);</span>
<span class="fc" id="L562">    Spdu spdu = new Spdu(spduHeader, stamp, serialSdu);</span>

    // Construire la SIDU
<span class="fc" id="L565">    SiduContext siduContext = new SiduContext(</span>
        session.initiatorId,
        session.peerId,
        session.initiatorIri,
<span class="fc" id="L569">        spdu.getHeader().getId(),</span>
        session.peerIri,
<span class="fc" id="L571">        false);</span>

    try {
<span class="fc" id="L574">      Sidu sidu = new Sidu(siduContext, sharedMapper.writeValueAsString(spdu));</span>
<span class="fc" id="L575">      String serialSidu = sharedMapper.writeValueAsString(sidu);</span>
<span class="fc" id="L576">      pendingResponse.add(new PendingConfirmation(token, session.sessionId,</span>
          MsgType.SES_FIN_ENV));
<span class="fc" id="L578">      logger.trace(Trace.ALGORITHM_1, &quot;serialSidu&quot;, serialSidu);</span>

<span class="fc" id="L580">      transportHost.dataRequest(serialSidu);</span>
<span class="fc" id="L581">      transportHost.dataConfirm();</span>
<span class="nc" id="L582">    } catch (JsonProcessingException e) {</span>
<span class="nc" id="L583">      throw new RuntimeException(e);</span>
<span class="fc" id="L584">    }</span>

<span class="fc" id="L586">    logger.trace(Trace.EXIT_METHOD_0);</span>
<span class="fc" id="L587">  }</span>

  public void closeSession(ExpandedSidu expandedSidu) {
<span class="fc" id="L590">    logger.trace(Trace.ENTER_METHOD_1, &quot;expandedSidu&quot;, expandedSidu);</span>
    // Supprimer du Tableau des réponses en attente, l’entrée de SES.FIN.ENV d’identifiant id.

    SesFinRecDto sdu;
    try {
<span class="fc" id="L595">      sdu = sharedMapper.readValue((String) expandedSidu.spdu().getContent(), SesFinRecDto.class);</span>
<span class="nc" id="L596">    } catch (JsonProcessingException e) {</span>
<span class="nc" id="L597">      throw new DeserializationException(e);</span>
<span class="fc" id="L598">    }</span>

<span class="fc" id="L600">    PendingConfirmation match = this.pendingResponse.stream()</span>
<span class="fc" id="L601">        .filter(x -&gt; x.uniqueId().equals(sdu.getToken()))</span>
<span class="fc" id="L602">        .findFirst()</span>
<span class="fc" id="L603">        .orElseThrow(() -&gt; new SessionTerminaisonFailedException(&quot;Element not found&quot;));</span>
<span class="fc" id="L604">    this.pendingResponse.remove(match);</span>
<span class="fc" id="L605">    SessionInformation session = this.sessionInformations.get(match.sessionId());</span>

    // Retirer les informations de session
<span class="fc" id="L608">    this.sessionInformations.remove(session.sessionId);</span>

    // Vérifier la correspondance avec le message d'envoi
<span class="pc bpc" id="L611" title="1 of 2 branches missed.">    if (!sdu.getToken().equals(match.uniqueId())) {</span>
<span class="nc" id="L612">      throw new SessionTerminaisonFailedException(&quot;Token does not match original token - &quot;</span>
<span class="nc" id="L613">          + &quot;orignal=&quot; + match.uniqueId() + &quot; response=&quot; + sdu.getToken());</span>
    }

<span class="fc" id="L616">    logger.trace(Trace.EXIT_METHOD_0);</span>
<span class="fc" id="L617">  }</span>

  public void loadSessionState() {
    // TODO
<span class="nc" id="L621">  }</span>

  public void saveSessionState() {
    // TODO
<span class="fc" id="L625">  }</span>

  public Map&lt;SessionId, SessionInformation&gt; getSessionInfo() {
<span class="fc" id="L628">    return Map.copyOf(this.sessionInformations);</span>
  }

  public ConcurrentLinkedQueue&lt;PendingConfirmation&gt; getPendingResponse() {
<span class="nc" id="L632">    return pendingResponse;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>