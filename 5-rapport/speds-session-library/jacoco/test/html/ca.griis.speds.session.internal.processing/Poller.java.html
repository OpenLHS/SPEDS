<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Poller.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">speds-session-library</a> &gt; <a href="index.source.html" class="el_package">ca.griis.speds.session.internal.processing</a> &gt; <span class="el_source">Poller.java</span></div><h1>Poller.java</h1><pre class="source lang-java linenums">/**
 * @file
 *
 * @copyright @@GRIIS_COPYRIGHT@@
 *
 * @licence @@GRIIS_LICENCE@@
 *
 * @version @@GRIIS_VERSION@@
 *
 * @brief @~french Implémentation de la classe PollingManager.
 * @brief @~english PollingManager class implementation.
 */

package ca.griis.speds.session.internal.processing;


import ca.griis.logger.GriisLogger;
import ca.griis.logger.GriisLoggerFactory;
import ca.griis.logger.statuscode.Debug;
import ca.griis.logger.statuscode.Error;
import ca.griis.logger.statuscode.Trace;
import ca.griis.speds.session.api.exception.DeserializationException;
import ca.griis.speds.session.internal.handler.HandlerRegistry;
import ca.griis.speds.transport.api.TransportHost;
import java.time.Duration;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.LinkedBlockingDeque;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;

/**
 * @brief @~english «Brief component description (class, interface, ...)»
 * @par Details
 *      «Detailed description of the component (optional)»
 * @par Model
 *      «Model (Abstract, automation, etc.) (optional)»
 * @par Conception
 *      «Conception description (criteria and constraints) (optional)»
 * @par Limits
 *      «Limits description (optional)»
 *
 * @brief @~french Implémente une boucle d’attente active pour récupérer les messages.
 * @par Details
 *      S.O.
 * @par Modèle
 *      S.O.
 * @par Conception
 *      S.O.
 * @par Limites
 *      S.O.
 *
 * @par Historique
 *      2025-05-14 [CB] - Implémentation initiale&lt;br&gt;
 *
 * @par Tâches
 *      S.O.
 */
public final class Poller {
<span class="fc" id="L63">  private static final GriisLogger logger = GriisLoggerFactory.getLogger(Poller.class);</span>

  private final ExecutorService executor;
  private final AtomicBoolean running;
  private final MessageDispatcher dispatcher;
  private final TransportHost transportHost;
  private final Duration pollingInterval;
  private final AtomicReference&lt;Future&lt;?&gt;&gt; future;
  private final BlockingQueue&lt;Exception&gt; exceptions;

  public Poller(TransportHost transportHost, MessageDispatcher dispatcher,
<span class="fc" id="L74">      Duration pollingInterval) {</span>
<span class="fc" id="L75">    logger.trace(Trace.ENTER_METHOD_3, &quot;transportHost&quot;, transportHost, &quot;dispatcher&quot;, dispatcher,</span>
        &quot;serverPollingInterval&quot;, pollingInterval);

<span class="fc" id="L78">    this.transportHost = transportHost;</span>
<span class="fc" id="L79">    this.executor = Executors.newSingleThreadExecutor();</span>
<span class="fc" id="L80">    this.running = new AtomicBoolean(false);</span>
<span class="fc" id="L81">    this.dispatcher = dispatcher;</span>
<span class="fc" id="L82">    this.pollingInterval = pollingInterval;</span>
<span class="fc" id="L83">    this.future = new AtomicReference&lt;&gt;(null);</span>
<span class="fc" id="L84">    this.exceptions = new LinkedBlockingDeque&lt;&gt;(10);</span>
<span class="fc" id="L85">  }</span>

  public Future&lt;?&gt; start() {
<span class="fc" id="L88">    logger.trace(Trace.ENTER_METHOD_0);</span>
<span class="pc bpc" id="L89" title="1 of 2 branches missed.">    if (running.compareAndSet(false, true)) {</span>
<span class="fc" id="L90">      future.set(executor.submit(this::pollLoop));</span>
    }

<span class="fc" id="L93">    Future&lt;?&gt; result = future.get();</span>
<span class="fc" id="L94">    logger.trace(Trace.EXIT_METHOD_1, &quot;result&quot;, result);</span>
<span class="fc" id="L95">    return result;</span>
  }

  public void stop() {
<span class="fc" id="L99">    logger.trace(Trace.ENTER_METHOD_0);</span>
<span class="fc" id="L100">    running.set(false);</span>
<span class="fc" id="L101">    shutdown();</span>
<span class="fc" id="L102">    logger.trace(Trace.EXIT_METHOD_0);</span>
<span class="fc" id="L103">  }</span>

  private void pollLoop() {
<span class="fc" id="L106">    logger.trace(Trace.ENTER_METHOD_0);</span>
<span class="fc bfc" id="L107" title="All 2 branches covered.">    while (running.get()) {</span>
      try {
<span class="fc" id="L109">        String msg = transportHost.dataReply();</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">        if (msg != null) {</span>
<span class="fc" id="L111">          dispatcher.dispatch(msg);</span>
        }

<span class="fc bfc" id="L114" title="All 2 branches covered.">        if (running.get()) {</span>
<span class="fc" id="L115">          Thread.sleep(pollingInterval.toMillis());</span>
        }
<span class="nc" id="L117">      } catch (InterruptedException e) {</span>
<span class="nc" id="L118">        Thread.currentThread().interrupt();</span>
<span class="nc" id="L119">        break;</span>
<span class="fc" id="L120">      } catch (DeserializationException e) {</span>
<span class="fc" id="L121">        logger.error(Error.IGNORED_ERROR, e);</span>
<span class="fc" id="L122">      } catch (Exception e) {</span>
<span class="pc bpc" id="L123" title="1 of 2 branches missed.">        if (!exceptions.offer(e)) {</span>
<span class="nc" id="L124">          throw new RuntimeException(e);</span>
        }
<span class="fc" id="L126">      }</span>
    }
<span class="fc" id="L128">    logger.trace(Trace.EXIT_METHOD_0);</span>
<span class="fc" id="L129">  }</span>

  /**
   * @brief @~english «Description of the function»
   * @param «parameter name» «Parameter description»
   * @exception «exception name» «Exception description»
   * @return «Return description»
   *
   * @brief @~french Désalloue le producteur non bloquant.
   *
   * @note 2024-02-20 - Comment correctement gérer l'exception d'interruption durant la
   *       désallocation du service d'exécution:
   *       https://www.baeldung.com/java-executor-wait-for-threads
   *
   * @par Tâches
   *      S.O.
   */
  protected void shutdown() {
<span class="fc" id="L147">    logger.trace(Trace.ENTER_METHOD_0);</span>

<span class="fc" id="L149">    executor.shutdown();</span>
    try {
<span class="fc bfc" id="L151" title="All 2 branches covered.">      if (!executor.awaitTermination(5, TimeUnit.SECONDS)) {</span>
<span class="fc" id="L152">        executor.shutdownNow();</span>
      }
<span class="fc" id="L154">    } catch (InterruptedException e) {</span>
<span class="fc" id="L155">      logger.debug(Debug.VARIABLE_LOGGING_1, &quot;e&quot;, e);</span>

<span class="fc" id="L157">      executor.shutdownNow();</span>

<span class="fc" id="L159">      Thread.currentThread().interrupt();</span>
<span class="fc" id="L160">    }</span>

<span class="fc" id="L162">    logger.trace(Trace.EXIT_METHOD_0);</span>
<span class="fc" id="L163">  }</span>

  public void registerHandlers(HandlerRegistry handlerRegistry) {
<span class="fc" id="L166">    this.dispatcher.registerHandlers(handlerRegistry);</span>
<span class="fc" id="L167">  }</span>

  public Exception getException() throws InterruptedException {
<span class="fc" id="L170">    return exceptions.take();</span>
  }

  public void clearExceptions() {
<span class="fc" id="L174">    exceptions.clear();</span>
<span class="fc" id="L175">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>